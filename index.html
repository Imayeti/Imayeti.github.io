<!-- there is a bug on enemy death where i get stuck and cant move. also the merchant should be buyable by looking at him not 
by stepping on him or else fix view of him. Give hime random wears that can be bought -->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <!-- <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"> -->

  <title>Canvas-Based Dungeon</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: black;
    }

    .container {
      display: flex;
      align-items: flex-start;
    }

    /* Environment preview container */
    #environment-container {
      text-align: left;
      margin-bottom: 10px;
      display: flex;
    }

    /* Environment preview image */
    #environment-image {
      width: 300px;
      border: 1px solid #333;
      object-fit: cover;
      margin-right: 20px;
    }

    /* Main game canvas */
    #dungeon-canvas {
      image-rendering: pixelated;
      display: block;
      margin-right: 20px;
    }

    /* Combat container section */
    #combat-section {
      border: 1px solid #333;
      padding: 10px;
      width: 600px;
      background: #fff;
      display: block;
      position: absolute;
      left: 50%;
      top: 50px;
    }

    #combat-section h2 {
      margin: 5px 0;
    }

    #notification-message {
      margin-top: 10px;
      font-weight: bold;
      max-height: 200px;
      overflow-y: scroll;
      line-height: 30px;;
    }

    /* Stats sections and health bars */
    .stats-container {
      display: flex;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .health-bar-container {
      width: 200px;
      background-color: #ccc;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 5px;
      height: 20px;
    }

    .health-fill {
      height: 20px;
      background-color: green;
      transition: width 0.3s ease;
    }

    /* Dice styling */
    .dice-container {
      display: inline-block;
      position: relative;
      width: 50px;
      height: 50px;
      margin: 5px;
    }

    .dice-container img {
      width: 50px;
      height: 50px;
    }

    /* Dice spin animation */
    .spin {
      animation: spin 0.3s linear;
    }

    @keyframes spin {
      0%   {transform: rotate(0deg);}
      100% {transform: rotate(120deg);}
    }
  </style>
</head>

<body>

  <!-- Environment preview section -->
  <div id="environment-container">
    <img 
      id="environment-image" 
      src="images/rooms/hallway-level-one-1.jpg" 
      alt="Dungeon Environment"
    >

    <div>
      <img 
        id="axe"
        src="images/weapons/axe.png" 
        alt="sword"
        style="width: 50px;"  
      >
    </div>
  </div>

  <div class="container">
    <!-- Main Game Canvas -->
    <canvas 
      id="dungeon-canvas" 
      width="600" 
      height="600"
    ></canvas>

    <!-- Combat Interface -->
    <div id="combat-section">
      <h2>Combat</h2>
      <div class="stats-container">
        <div>
          <h3>Player</h3>

          <div style="display: flex;">
            <img 
              src="images/items/credits.jpg" 
              alt="Player" 
              style="width: 60px;">

            <h2 style="margin-left: 10px" id="player-credits"></h2>
          </div>

          <h4>Inventory</h4>
          <div id="player-inventory" class="flex"></div>

          <!-- Player Health -->
          <div id="player-health-label"></div>
          <div class="health-bar-container">
            <div 
              id="player-health-bar" 
              class="health-fill">
            </div>
          </div>
          <p>Attack: <span id="player-attack-value"></span></p>
        </div>
      </div>

      <div class="stats-container">
        <div>
          <h3 id="enemy-name"></h3>
          <!-- Enemy Health -->
          <div id="enemy-health-label"></div>
          <div class="health-bar-container">
            <div 
              id="enemy-health-bar" 
              class="health-fill">
            </div>
          </div>
          <p>Attack: <span id="enemy-attack-value"></span></p>
        </div>
      </div>

      <!-- Attack button and dice rolls -->
      <div>
        <button id="player-attack-button">Attack</button>
        <div style="margin-top:10px;">
          <div class="dice-container">
            <img 
              id="player-dice" 
              src="images/dice.png" 
              alt="Player Dice"
            >
          </div>
          <span id="player-dice-roll-result"></span>
        </div>
        <div style="margin-top:10px;">
          <div class="dice-container">
            <img 
              id="enemy-dice" 
              src="images/dice.png" 
              alt="Enemy Dice"
            >
          </div>
          <span id="enemy-dice-roll-result"></span>
        </div>
        <div id="notification-message"></div>
      </div>
    </div>

    <!-- Loot container -->
    <div>
      <div 
        id="player-loot" 
        class="loot-container flex items-center mt-2">
        Loot items will be rendered here
      </div>
    </div>
  </div>

  <script>
    /*
      ---------------------------------------------------
      Class Definitions
      ---------------------------------------------------
    */

    // Monster class
    class Monster {
      constructor(name, health, attack, diceType, imagePath) {
        this.startingHealth = health;
        this.name = name;
        this.health = health;
        this.attack = attack;
        this.defeated = false;
        this.diceType = diceType;
        this.imagePath = imagePath;
      }
    }

    // Player class
    class Player {
      constructor(health, attack) {
        this.startingHealth = health;
        this.health = health;
        this.attack = attack;
        this.inventory = [{ id: randomId(), name: 'Bandage', type: 'heal', effect: 20, image: 'images/items/health.jpg' }]; // Add inventory to store loot items
        this.credits = 0;
        this.experience = 0;
      }
    }

    /*
      ---------------------------------------------------
      Global Variables & Constants
      ---------------------------------------------------
    */

    // Initialize the Player instance
    const playerCharacter = new Player(100, 1);

    // Directions used for player movement and arrow indication
    let currentFacingDirection = 'up';
    const directionArrows = {
      'up': '↑',
      'down': '↓',
      'left': '←',
      'right': '→'
    };

    // Tile size and enemy movement speed
    const TILE_SIZE = 30;
    const ENEMY_SPEED = 0.2; 
    const ENEMY_SIZE = TILE_SIZE / 2;

    // DOM Element references
    const dungeonCanvas = document.getElementById('dungeon-canvas');
    const drawingContext = dungeonCanvas.getContext('2d');
    const environmentImageElement = document.getElementById('environment-image');
    const combatSection = document.getElementById('combat-section');
    const playerHealthLabel = document.getElementById('player-health-label');
    const playerHealthBar = document.getElementById('player-health-bar');
    const playerAttackValue = document.getElementById('player-attack-value');
    const playerInventory = document.getElementById('player-inventory');
    const playerCredits = document.getElementById('player-credits');
    const enemyHealthLabel = document.getElementById('enemy-health-label');
    const enemyHealthBar = document.getElementById('enemy-health-bar');
    const enemyNameLabel = document.getElementById('enemy-name');
    const enemyAttackValue = document.getElementById('enemy-attack-value');
    const notificationMessageDiv = document.getElementById('notification-message');
    const playerAttackButton = document.getElementById('player-attack-button');
    const playerDiceElement = document.getElementById('player-dice');
    const enemyDiceElement = document.getElementById('enemy-dice');
    const playerDiceRollResult = document.getElementById('player-dice-roll-result');
    const enemyDiceRollResult = document.getElementById('enemy-dice-roll-result');

    const axeBuy = document.getElementById('axe');
    axeBuy.style.display = 'none';

    axeBuy.addEventListener('click', () => {
      if (playerCharacter.credits >= 50) {
        playerCharacter.credits -= 50;
        const damage = randomBetween(10, 20);
        axe = { id: randomId(), name: 'Axe', type: 'attack', effect: damage, image: 'images/weapons/axe.png', poa: 'passive' }
        playerCharacter.inventory.push();
        playerCharacter.attack += axe.effect;
        
        notify('You bought an axe that hits for ' + damage);
        updateCombatUI();
      } else {
        notify('Not enough credits to buy an axe!');
      }
    });



    // Dungeon maps, enemies, and tracking states
    let dungeonRooms = [];
    let monsterLookup = {};
    let currentDungeonRoomIndex = 0;
    let playerTileX, playerTileY;
    let currentBattleMonster = null;
    let isInCombat = false;
    let isPlayerRollingDice = false;
    let totalDefeatedMonsters = 0;

    // Level management
    let currentDungeonLevel = 1;
    const MAX_DUNGEON_LEVELS = 500;

    /*
      ---------------------------------------------------
      Key Listener for Movement & Attack
      ---------------------------------------------------
    */
    document.addEventListener('keydown', (e) => {
      if (e.key === ' ') {
          console.log('Attack!');
          // Press space to attack (debug / convenience)
          playerAttackButton.click();
      }
      
      // If in combat, ignore movement
      if (isInCombat) return;

      let movementDirection = null;

      // Check which key was pressed
      if (e.key === 'ArrowUp') {
        movementDirection = 'up';
      } else if (e.key === 'ArrowDown') {
        movementDirection = 'down';
      } else if (e.key === 'ArrowLeft') {
        movementDirection = 'left';
      } else if (e.key === 'ArrowRight') {
        movementDirection = 'right';
      } else {
        return;
      }

      // If newly pressed direction is different, just change facing direction
      if (movementDirection !== currentFacingDirection) {
        currentFacingDirection = movementDirection;
        updateEnvironmentPreview();
        renderVisibleTiles();
        return;
      } else {
        // Attempt to move one tile in the facing direction
        const { xOffset, yOffset } = convertDirectionToOffset(currentFacingDirection);
        const nextTileX = playerTileX + xOffset;
        const nextTileY = playerTileY + yOffset;

        // Check if player can move onto that tile
        if (canMoveToTile(nextTileX, nextTileY)) {
          playerTileX = nextTileX;
          playerTileY = nextTileY;

          const activeRoom = dungeonRooms[currentDungeonRoomIndex];
          activeRoom.discovered[playerTileY][playerTileX] = true;
          discoverSurroundingTiles(playerTileX, playerTileY);

          const tileValue = activeRoom.map[playerTileY][playerTileX];

          // Check for healing tile
          if (tileValue === 4) {
            playerCharacter.health = playerCharacter.startingHealth;
            notify("You have been fully healed!");
            updateCombatUI();
            activeRoom.map[playerTileY][playerTileX] = 0;
          } 

          //Chest
          if (tileValue === 5) {
            let itemFound = false;

            if (chance(85)) {
              if (chance(50)) {
                  itemFound = true;
                  const bandage = { id: randomId(), name: 'Bandage', type: 'heal', effect: 30, image: 'images/items/health.jpg',  poa: 'active' };
                  playerCharacter.inventory.push(bandage);
                  console.log(playerCharacter.inventory);
                  notify('You found a Bandage!');
              } 
              
              if (chance(30) && !playerCharacter.inventory.find(item => item.name === 'Plasma Dagger')) {
                  itemFound = true;
                  const plasmaDagger = { id: randomId(), name: 'Plasma Dagger', type: 'attack', effect: 5, image: 'images/weapons/plasma-dagger.jpg', poa: 'passive' };
                  playerCharacter.inventory.push(plasmaDagger);
                  playerCharacter.attack += plasmaDagger.effect;
                  console.log(playerCharacter.inventory);
                  notify('You found a Plasma Dagger!');
              } else if (chance(30) && !playerCharacter.inventory.find(item => item.name === 'Aetherweaver')) {
                  itemFound = true;
                  const aetherweaver = { id: randomId(), name: 'Aetherweaver', type: 'attack', effect: 7, image: 'images/weapons/aetherweaver.jpg', poa: 'passive' };
                  playerCharacter.inventory.push(aetherweaver);
                  playerCharacter.attack += aetherweaver.effect;
                  console.log(playerCharacter.inventory);
                  notify('You found an Aetherweaver!');
              }

              if (chance(30)) {
                  itemFound = true;
                  const grenade = { id: randomId(), name: 'grenade', type: 'attack', effect: 30, image: 'images/weapons/grenade.jpg',  poa: 'active' };
                  playerCharacter.inventory.push(grenade);
                  console.log(playerCharacter.inventory);
                  notify('You found an grenade!');
              }

              if (chance(30)) {
                  itemFound = true;
                  const amount = randomIntFromInterval(3,35);
                  const credit = { id: randomId(), name: 'green credits', type: 'credits', effect: amount, image: 'images/rooms/credits.jpg',  poa: 'passive' };
                  playerCharacter.credits += credit.effect;
                  console.log(playerCharacter.inventory);
                  notify(`You found ${amount} amount of credits!`);
              }
            } 

            if (!itemFound) {
                notify('The chest was empty.');
            }

            activeRoom.map[playerTileY][playerTileX] = 0;
            updateCombatUI();
          }
          
          // Check for door to next level
          else if (tileValue === 2) {
            if (currentDungeonLevel < MAX_DUNGEON_LEVELS) {
              currentDungeonLevel++;
              notify(`You proceed to level ${currentDungeonLevel}!`);
              generateAndLoadNextLevelRoom();
              return;
            } else {
              notify("You have completed all levels! You Win!");
            }
          } 
          
          // Check for merchant tile
          else if (tileValue === 6) {
            axeBuy.style.display = 'block';
            updateCombatUI();
          } else {
            axeBuy.style.display = 'none';
          }



          updateEnvironmentPreview();
          renderVisibleTiles();
          checkForPlayerEnemyOverlap();
        }
      }
    });

    /*
      ---------------------------------------------------
      Helper Functions
      ---------------------------------------------------
    */

    // Convert our direction string into numeric tile offsets
    function convertDirectionToOffset(direction) {
      if (direction === 'up')   return { xOffset: 0,  yOffset: -1 };
      if (direction === 'down') return { xOffset: 0,  yOffset: 1 };
      if (direction === 'left') return { xOffset: -1, yOffset: 0 };
      if (direction === 'right')return { xOffset: 1,  yOffset: 0 };
      return { xOffset: 0, yOffset: 0 };
    }

    // Check if a tile is walkable
    function canMoveToTile(x, y) {
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];

      // If out of bounds, not walkable
      if (
        y < 0 || 
        y >= activeRoom.map.length || 
        x < 0 || 
        x >= activeRoom.map[0].length
      ) {
        return false;
      }

      const tileValue = activeRoom.map[y][x];
      // tileValue 1 is a wall, so return false
      if (tileValue === 1) {
        return false;
      }

      return true;
    }

    // Reveals surrounding tiles around the player
    function discoverSurroundingTiles(px, py) {
      const deltas = [
        [0, 0],
        [0, -1],
        [0, 1],
        [-1, 0],
        [1, 0]
      ];

      const activeRoom = dungeonRooms[currentDungeonRoomIndex];
      for (let [dx, dy] of deltas) {
        const nearbyX = px + dx;
        const nearbyY = py + dy;
        if (
          nearbyY >= 0 && 
          nearbyY < activeRoom.map.length && 
          nearbyX >= 0 && 
          nearbyX < activeRoom.map[0].length
        ) {
          activeRoom.discovered[nearbyY][nearbyX] = true;
        }
      }
    }

    // Render the tiles within a certain range around the player
    function renderVisibleTiles() {
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];

      // Clear the canvas
      drawingContext.clearRect(0, 0, dungeonCanvas.width, dungeonCanvas.height);

      // Determine the viewport around the player
      const viewportStartX = Math.max(0, playerTileX - 10);
      const viewportStartY = Math.max(0, playerTileY - 10);
      const viewportEndX = Math.min(activeRoom.map[0].length, playerTileX + 10);
      const viewportEndY = Math.min(activeRoom.map.length, playerTileY + 10);

      // Loop over all visible tiles
      for (let y = viewportStartY; y < viewportEndY; y++) {
        for (let x = viewportStartX; x < viewportEndX; x++) {
          if (!activeRoom.discovered[y][x]) {
            // Undiscovered tiles are black
            drawingContext.fillStyle = "#000";
          } else {
            // Draw known tiles based on tile value
            const tileValue = activeRoom.map[y][x];
            if (tileValue === 1) {
              drawingContext.fillStyle = "#888"; // Wall
            } else if (tileValue === 2) {
              drawingContext.fillStyle = "#00c"; // Door
            } else if (tileValue === 4) {
              drawingContext.fillStyle = "#0c0"; // Healing
            } else if (tileValue === 5) {
              drawingContext.fillStyle = "#f2d675"; // loot
            } else if (tileValue === 6) {             
              drawingContext.fillStyle = "#b8e6bf"; // loot
            } else {
              drawingContext.fillStyle = "#fff"; // Floor / Empty space
            }
          }

          drawingContext.fillRect(
            (x - viewportStartX) * TILE_SIZE,
            (y - viewportStartY) * TILE_SIZE,
            TILE_SIZE,
            TILE_SIZE
          );
        }
      }

      // Draw the player
      drawingContext.fillStyle = "rgb(13,128,13)";
      drawingContext.fillRect(
        (playerTileX - viewportStartX) * TILE_SIZE,
        (playerTileY - viewportStartY) * TILE_SIZE,
        TILE_SIZE,
        TILE_SIZE
      );

      // Draw the arrow showing player facing direction
      drawingContext.fillStyle = "#fff";
      drawingContext.font = "20px sans-serif";
      drawingContext.textAlign = "center";
      drawingContext.textBaseline = "middle";
      drawingContext.fillText(
        directionArrows[currentFacingDirection],
        (playerTileX - viewportStartX) * TILE_SIZE + TILE_SIZE / 2,
        (playerTileY - viewportStartY) * TILE_SIZE + TILE_SIZE / 2
      );

      // Draw enemies within the viewport if discovered
      for (let enemyObj of activeRoom.enemies) {
        // Calculate the enemy's tile index
        const enemyCenterX = enemyObj.xPos + ENEMY_SIZE / 2;
        const enemyCenterY = enemyObj.yPos + ENEMY_SIZE / 2;
        const enemyTileX = Math.floor(enemyCenterX / TILE_SIZE);
        const enemyTileY = Math.floor(enemyCenterY / TILE_SIZE);

        // Ensure the enemy tile is inside the visible portion
        if (
          enemyTileY >= viewportStartY && 
          enemyTileY < viewportEndY &&
          enemyTileX >= viewportStartX && 
          enemyTileX < viewportEndX &&
          activeRoom.discovered[enemyTileY][enemyTileX]
        ) {
          // Compute on-canvas coordinates
          const enemyScreenX = (enemyTileX - viewportStartX) * TILE_SIZE + (ENEMY_SIZE - TILE_SIZE) / 2;
          const enemyScreenY = (enemyTileY - viewportStartY) * TILE_SIZE + (ENEMY_SIZE - TILE_SIZE) / 2;

          // Draw the enemy in red
          drawingContext.fillStyle = "#a00";
          drawingContext.fillRect(enemyScreenX, enemyScreenY, ENEMY_SIZE, ENEMY_SIZE);
        }
      }
    }

    // Display text messages to the player in the notification div
    function notify(message) {
      notificationMessageDiv.innerHTML = message + '<br>' + notificationMessageDiv.innerHTML ;
    }

    // Check for collision of player and any enemy
    function checkForPlayerEnemyOverlap() {
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];
      const playerPixelX = playerTileX * TILE_SIZE;
      const playerPixelY = playerTileY * TILE_SIZE;

      for (let enemyObj of activeRoom.enemies) {
        if (
          rectanglesOverlap(
            playerPixelX,
            playerPixelY,
            TILE_SIZE,
            TILE_SIZE,
            enemyObj.xPos,
            enemyObj.yPos,
            ENEMY_SIZE,
            ENEMY_SIZE
          )
        ) {
          // Start combat if the enemy isn't already defeated
          if (!isInCombat && !enemyObj.monster.defeated) {
            currentBattleMonster = enemyObj.monster;
            isInCombat = true;
            environmentImageElement.src = currentBattleMonster.imagePath;
            combatSection.style.display = 'block';
            updateCombatUI();
            notify(`A ${currentBattleMonster.name} appears!`);
          }
          return;
        }
      }
    }

    // Basic rectangle overlap utility
    function rectanglesOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
      return (
        ax < bx + bw && 
        ax + aw > bx && 
        ay < by + bh && 
        ay + ah > by
      );
    }

    /*
      ---------------------------------------------------
      Combat Handling
      ---------------------------------------------------
    */

    // Update the combat UI with current player/enemy stats
    function updateCombatUI() {
      //render player credits
      playerCredits.innerHTML = `${playerCharacter.credits}`;

      //set items to display
      //get items from the player inventory then render them
      playerInventory.innerHTML = '';
      for (let i = 0; i < playerCharacter.inventory.length; i++) {
        const item = playerCharacter.inventory[i];
        const itemImage = document.createElement('img');
        itemImage.style.width = '40px';
        itemImage.src = item.image;
        itemImage.alt = item.name;
        itemImage.title = item.name;
        itemImage.addEventListener('click', () => useLootItem(item));
        playerInventory.appendChild(itemImage);
      }


      // Update player info
      playerHealthLabel.innerHTML = `Health: ${playerCharacter.health}/${playerCharacter.startingHealth}`;
      playerAttackValue.innerHTML = playerCharacter.attack;
      refreshHealthBar(
        playerHealthBar, 
        playerCharacter.health, 
        playerCharacter.startingHealth
      );

      // Update enemy info
      if (currentBattleMonster) {
        enemyNameLabel.innerHTML = currentBattleMonster.name;
        enemyHealthLabel.innerHTML = `Health: ${currentBattleMonster.health}/${currentBattleMonster.startingHealth}`;
        enemyAttackValue.innerHTML = currentBattleMonster.attack;
        refreshHealthBar(
          enemyHealthBar, 
          currentBattleMonster.health, 
          currentBattleMonster.startingHealth
        );
      }
    }

    // Health bar progress logic
    function refreshHealthBar(barElement, currentValue, maxValue) {
      const percentage = Math.max(0, (currentValue / maxValue) * 100);
      barElement.style.width = percentage + '%';
      barElement.style.backgroundColor = (percentage < 30) ? 'red' : 'green';
    }

    // End combat and handle post-battle logic
    function concludeCombat() {
      currentBattleMonster = null;
      isInCombat = false;

      // Keep the combat container up but clear the notification
      combatSection.style.display = 'block';

      // If all enemies in the room are defeated, place the door
      if (areAllEnemiesDefeated()) {
        placeExitDoorInCurrentRoom();
        renderVisibleTiles();
      }
    }

    // Check if all enemies are defeated in the current room
    function areAllEnemiesDefeated() {
      const enemiesInRoom = dungeonRooms[currentDungeonRoomIndex].enemies;
      for (let enemyObj of enemiesInRoom) {
        if (!enemyObj.monster.defeated) {
          return false;
        }
      }
      return true;
    }

    // Place a door tile in the current room after defeating all enemies
    function placeExitDoorInCurrentRoom() {
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];

      // Only place a door if not beyond the max level
      if (currentDungeonLevel <= MAX_DUNGEON_LEVELS) {
        const width = activeRoom.map[0].length;
        const height = activeRoom.map.length;

        const randomX = Math.floor(Math.random() * (width - 2)) + 1;
        const doorY = height - 1;

        activeRoom.map[doorY][randomX] = 2;
      }
    }

    function placeMerchantInCurrentRoom() {
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];

      // Only place a door if not beyond the max level
      if (currentDungeonLevel <= MAX_DUNGEON_LEVELS) {
        const width = activeRoom.map[0].length;
        const height = activeRoom.map.length;

        const randomX = Math.floor(Math.random() * (width - 2)) + 1;
        const doorY = height - 1;

        activeRoom.map[doorY][randomX] = 6;
      }
    }

    function lootEnemy() {
      console.log('Looting enemy...');
      if (chance(70)) {
        console.log('Looted enemy!');
        const amount = randomIntFromInterval(1, 10);
        const credit = { id: randomId(), name: 'green credits', type: 'credits', effect: amount, image: 'images/rooms/credits.jpg',  poa: 'passive' };
        playerCharacter.credits += credit.effect;
        notify(`You found ${amount} credits!`);
      } else {
        console.log('No loot found.');
        notify('Nothing found.');
      }

      updateCombatUI();
    }

    // Remove all enemies with monster.defeated = true
    // defeat monster defeatMonster
    function removeDefeatedEnemies() {
      lootEnemy();
      totalDefeatedMonsters++;
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];
      activeRoom.enemies = activeRoom.enemies.filter(e => !e.monster.defeated);
    }

    // Player Attack button event
    playerAttackButton.addEventListener('click', async () => {
      // If no current enemy or it's already dead, or if the player is already rolling dice, do nothing
      if (!currentBattleMonster || currentBattleMonster.health <= 0 || isPlayerRollingDice) {
        return;
      }

      isPlayerRollingDice = true;

      // Roll the player's die
      const playerRollValue = await performDiceRoll(playerDiceElement, 'd20');
      playerDiceRollResult.textContent = `You rolled ${playerRollValue}`;

      // If roll is 1 or lower, it’s a miss
      if (playerRollValue <= 1) {
        notify("You missed!");
        await waitForMs(1000);
        isPlayerRollingDice = false;
        processEnemyTurn();
        return;
      }

      // Calculate total damage
      let totalPlayerDamage = playerCharacter.attack + playerRollValue;
      currentBattleMonster.health -= totalPlayerDamage;
      notify(
        `You dealt ${totalPlayerDamage} damage to ${currentBattleMonster.name}.`
      );
      updateCombatUI();

      // Check if enemy is defeated
      if (currentBattleMonster.health <= 0) {
        isPlayerRollingDice = false;
        notify(`${currentBattleMonster.name} is defeated!`);
        currentBattleMonster.defeated = true;

        removeDefeatedEnemies();
        concludeCombat();
        renderVisibleTiles();
        updateEnvironmentPreview();
        return;
      }

      // Otherwise, wait and let the enemy take a turn
      await waitForMs(1000);
      isPlayerRollingDice = false;
      processEnemyTurn();
    });

    // Enemy's turn logic
    async function processEnemyTurn() {
      if (!currentBattleMonster || currentBattleMonster.health <= 0) {
        return;
      }

      // Enemy rolls
      const enemyRollValue = await performDiceRoll(enemyDiceElement, currentBattleMonster.diceType);
      enemyDiceRollResult.textContent = `${currentBattleMonster.name} rolled ${enemyRollValue}`;

      // Miss
      if (enemyRollValue <= 1) {
        notify(`${currentBattleMonster.name} missed!`);
        return;
      }

      // Calculate enemy damage
      let totalEnemyDamage = currentBattleMonster.attack + enemyRollValue;
      playerCharacter.health -= totalEnemyDamage;
      notify(`${currentBattleMonster.name} dealt ${totalEnemyDamage} damage to you!`);
      updateCombatUI();

      // Check if player is defeated
      if (playerCharacter.health <= 0) {
        playerCharacter.health = 0;
        notify("You have been defeated!");
        alert("Game Over! You defeated " + totalDefeatedMonsters + " monsters and you reached level " + currentDungeonLevel + "!");
        concludeCombat();
      }
    }

    // Dice roller utility function
    async function performDiceRoll(diceElement, diceType) {
      let sideCount = 20; // Default is d20
      if      (diceType === 'd6')  sideCount = 6;
      else if (diceType === 'd10') sideCount = 10;
      else if (diceType === 'd12') sideCount = 12;
      else if (diceType === 'd8')  sideCount = 8;

      // Spin the dice image for animation, then wait
      animateDiceRoll(diceElement);
      await waitForMs(350);

      // Compute random roll
      const roll = Math.floor(Math.random() * sideCount) + 1;
      return roll;
    }

    // Animate the dice element by adding the .spin class
    function animateDiceRoll(diceImg) {
      diceImg.classList.add('spin');
      setTimeout(() => diceImg.classList.remove('spin'), 500);
    }

    // Utility function to wait for a given number of milliseconds
    function waitForMs(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function randomIntFromInterval(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function randomId() {
      return Math.random().toString(36).substr(2, 9);
    }

    /*
      ---------------------------------------------------
      Enemy Movement (Outside of Combat)
      ---------------------------------------------------
    */

    // Move enemies if not in combat
    function updateAllEnemies() {
      if (isInCombat) return;

      const activeRoom = dungeonRooms[currentDungeonRoomIndex];

      for (let enemyObj of activeRoom.enemies) {
        let oldXPos = enemyObj.xPos;
        let oldYPos = enemyObj.yPos;
        let newXPos = oldXPos + (enemyObj.xDir * ENEMY_SPEED);
        let newYPos = oldYPos + (enemyObj.yDir * ENEMY_SPEED);

        // If the enemy can't move to the new spot, choose a new direction
        if (!canEnemyMoveToPixel(newXPos, newYPos)) {
          const possibleDirections = [
            { xDir: 0,  yDir: -1 },
            { xDir: 0,  yDir: 1 },
            { xDir: -1, yDir: 0 },
            { xDir: 1,  yDir: 0 }
          ];
          const newDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];
          enemyObj.xDir = newDirection.xDir;
          enemyObj.yDir = newDirection.yDir;
          newXPos = oldXPos + (enemyObj.xDir * ENEMY_SPEED);
          newYPos = oldYPos + (enemyObj.yDir * ENEMY_SPEED);

          // If it still can't move, skip moving this frame
          if (!canEnemyMoveToPixel(newXPos, newYPos)) {
            continue;
          }
        }

        // Update enemy position
        enemyObj.xPos = newXPos;
        enemyObj.yPos = newYPos;
      }

      // Check again for collisions
      checkForPlayerEnemyOverlap();
    }

    // Check if an enemy can move to a certain pixel
    function canEnemyMoveToPixel(pixelX, pixelY) {
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];
      const enemyCenterX = pixelX + (ENEMY_SIZE / 2);
      const enemyCenterY = pixelY + (ENEMY_SIZE / 2);
      const tileX = Math.floor(enemyCenterX / TILE_SIZE);
      const tileY = Math.floor(enemyCenterY / TILE_SIZE);

      // If out of bounds, can't move
      if (
        tileY < 0 ||
        tileY >= activeRoom.map.length ||
        tileX < 0 ||
        tileX >= activeRoom.map[0].length
      ) {
        return false;
      }

      const tileValue = activeRoom.map[tileY][tileX];

      // Enemies cannot move onto walls, doors, or healing tiles
      if (tileValue === 1 || tileValue === 2 || tileValue === 4) {
        return false;
      }

      return true;
    }

    /*
      ---------------------------------------------------
      Environment Image Updates
      ---------------------------------------------------
    */

    // Update the environment image based on what's in front of the player
    function updateEnvironmentPreview() {
      // If in combat, show the enemy’s image
      if (isInCombat && currentBattleMonster) {
        environmentImageElement.src = currentBattleMonster.imagePath;
        return;
      }

      // Otherwise, look at the tile in front of the player
      const { xOffset, yOffset } = convertDirectionToOffset(currentFacingDirection);
      const activeRoom = dungeonRooms[currentDungeonRoomIndex];
      const tileAheadX = playerTileX + xOffset;
      const tileAheadY = playerTileY + yOffset;

      let tileValueAhead = 1;
      if (
        tileAheadY >= 0 && 
        tileAheadY < activeRoom.map.length &&
        tileAheadX >= 0 && 
        tileAheadX < activeRoom.map[0].length
      ) {
        tileValueAhead = activeRoom.map[tileAheadY][tileAheadX];
      }

      // Switch images based on tile type
      if (tileValueAhead === 4) {
        environmentImageElement.src = 'images/rooms/healing-room.png';
      } else if (tileValueAhead === 2) {
        environmentImageElement.src = 'images/rooms/level-one-door.png';
      } else if (tileValueAhead === 1) {
        environmentImageElement.src = 'images/rooms/wall.png';
      } else if (tileValueAhead === 5) {
        environmentImageElement.src = 'images/rooms/chest.png';
      } else if (tileValueAhead === 6) {
        environmentImageElement.src = 'images/chars/merchant.png';
      } else {
        environmentImageElement.src = 'images/rooms/hallway-level-one-1.jpg';
      }
    }

    /*
      ---------------------------------------------------
      Dungeon Generation
      ---------------------------------------------------
    */

    // Generate a new random room
    function generateRandomRoom(
      minWidth = 10, 
      maxWidth = 35, 
      minHeight = 10, 
      maxHeight = 35
    ) {
      // Create random width and height in given ranges
      const roomWidth = Math.floor(Math.random() * (maxWidth - minWidth + 1)) + minWidth;
      const roomHeight = Math.floor(Math.random() * (maxHeight - minHeight + 1)) + minHeight;

      let newRoomMap = [];
      let discoveredTiles = [];

      // Initialize map
      for (let y = 0; y < roomHeight; y++) {
        newRoomMap[y] = [];
        discoveredTiles[y] = [];
        for (let x = 0; x < roomWidth; x++) {
          newRoomMap[y][x] = 0;      // 0 means empty floor
          discoveredTiles[y][x] = false;
        }
      }

      // Walls along perimeter
      for (let x = 0; x < roomWidth; x++) {
        newRoomMap[0][x] = 1;            // top row
        newRoomMap[roomHeight - 1][x] = 1; // bottom row
      }
      for (let y = 0; y < roomHeight; y++) {
        newRoomMap[y][0] = 1;              // left column
        newRoomMap[y][roomWidth - 1] = 1;  // right column
      }

      // Random healing tile
      if (Math.random() < 0.25) {
        placeRandomTile(newRoomMap, 4);
      }

      //for loop to do this 5 times
      for (let i = 0; i < 6; i++) {
        if (Math.random() < 0.25) {
          placeRandomTile(newRoomMap, 5, true);
        }
      }

      // Place random walls (10% of total tiles)
      const totalTiles = roomWidth * roomHeight;
      const numberOfWalls = Math.floor(totalTiles * 0.1);
      for (let i = 0; i < numberOfWalls; i++) {
        placeRandomTile(newRoomMap, 1, true);
      }

      // Hardcoded monster count for demonstration
      const monsterCount = randomIntFromInterval(3, 8);
      //number of enemies numEnemies num enemies
      // const monsterCount = 25;

      const possibleMonsters = [
          { 
              name: "Rust Crawler", 
              health: 40 + (currentDungeonLevel * 2), 
              attack: 1, 
              defense: 2, 
              dice: 'd6', 
              img: 'images/enemies/rust-crawler.png', 
              description: "The Rust Crawler is a small, scuttling mechanical enemy designed for basic reconnaissance and light defense. It resembles a spider-like robot with six thin, spindly legs and a rusted, worn metal carapace. Despite its deteriorated appearance, it moves surprisingly quickly, using its sharp legs to stab at intruders. It’s equipped with a low-powered shock attack that deals minor damage, intended more to annoy than to seriously harm. Found in abandoned hallways and near malfunctioning terminals, the Rust Crawler is usually encountered in groups, making them a challenge in numbers." 
          },
          { 
              name: "Glow Leech", 
              health: 60 + (currentDungeonLevel * 2), 
              attack: 2, 
              defense: 3, 
              dice: 'd6', 
              img: 'images/enemies/glow-leech.png', 
              description: "The Glow Leech is a slow-moving, slug-like alien that thrives in the damp, abandoned corridors of the underground base. Its translucent, glowing green body emits a faint light, making it easy to spot but unnerving to approach. Beneath its slimy exterior, pulsating veins carry bioelectric energy. The Glow Leech feeds on energy sources, latching onto its prey to drain their stamina. While not physically strong, its energy-draining attack can leave players vulnerable in subsequent encounters." 
          },
          { 
              name: "Fracture Sentinel", 
              health: 30 + (currentDungeonLevel * 2), 
              attack: 3, 
              defense: 3, 
              dice: 'd6', 
              img: 'images/enemies/shard-sentinel.jpg', 
              description: "The Fracture Sentinel is a large, floating crystal construct that guards the entrance to the underground base. Its body is composed of jagged, multi-faceted shards that refract light in a dazzling display of colors. The Fracture Sentinel is equipped with a powerful laser attack that can pierce through armor and deal significant damage. It’s also capable of generating a protective shield that absorbs incoming damage, making it a formidable opponent in battle. The Fracture Sentinel is usually encountered alone, as its presence is enough to deter most intruders." 
          },
          { 
              name: "Scrap Vulture", 
              health: 55 + (currentDungeonLevel * 2), 
              attack: 3, 
              defense: 3, 
              dice: 'd6', 
              img: 'images/enemies/vulture.jpg', 
              description: "The Scrap Vulture is a mechanical scavenger that roams abandoned corridors. Its sharp beak and talons are designed to tear apart both machinery and intruders. Found near broken machinery or trash piles, this enemy strikes with swift and precise attacks, making it a significant threat in close quarters." 
          },
          { 
              name: "Chrono Sentinel", 
              health: 70 + (currentDungeonLevel * 2), 
              attack: 4, 
              defense: 5, 
              dice: 'd8', 
              img: 'images/enemies/chrono-sentinel.jpg', 
              description: "The Chrono Sentinel is a mechanical guardian with spinning limbs and glowing energy cores. It uses its high-tech arsenal to deal heavy damage and defend key locations. Its ability to disrupt time-based technologies makes it especially dangerous to unprepared adventurers." 
          },
          { 
              name: "Viper", 
              health: 50 + (currentDungeonLevel * 2), 
              attack: 4, 
              defense: 2, 
              dice: 'd8', 
              img: 'images/enemies/viper.jpg', 
              description: "The Neon Viper is a cybernetic serpent with glowing green scales and a deadly venomous bite. It can lunge at its target with surprising speed, dealing poison damage over time. Found in dark and damp corridors, it blends into its environment, waiting to ambush its prey." 
          },
          { 
              name: "Mist Reaver", 
              health: 40 + (currentDungeonLevel * 2), 
              attack: 5 + currentDungeonLevel , 
              defense: 1, 
              dice: 'd12', 
              img: 'images/enemies/mist-reaver.jpg', 
              description: "The Ethereal Drone is a hovering, otherworldly construct that emits an eerie mist. It can phase in and out of existence, making it difficult to hit. Its energy attacks can disorient its targets, leaving them vulnerable to further damage." 
          },
          { 
              name: "Vanguard Stalker", 
              health: 45 + (currentDungeonLevel * 2), 
              attack: 6, 
              defense: 3, 
              dice: 'd8', 
              img: 'images/enemies/vanguard-stalker.jpg', 
              description: "The Vanguard Stalker is a spider-like robotic predator with sharp, bladed limbs and a glowing core. It is agile and relentless, striking quickly and retreating before its target can react. Its core emits an energy blast, dealing area damage when threatened." 
          }
      ];

      const newRoomIndex = dungeonRooms.length;
      let enemyPositions = [];

      // Place monster tiles
      for (let i = 0; i < monsterCount; i++) {
        const { x, y } = placeRandomTile(newRoomMap, 3, true);
        const monsterTemplate = possibleMonsters[
          Math.floor(Math.random() * possibleMonsters.length)
        ];
        const newMonster = new Monster(
          monsterTemplate.name,
          monsterTemplate.health,
          monsterTemplate.attack,
          monsterTemplate.dice,
          monsterTemplate.img
        );

        // Create a lookup for the monster
        monsterLookup[`${newRoomIndex}-${x}-${y}`] = newMonster;
        enemyPositions.push({ x: x, y: y });
      }

      // Pick a random start position for the player
      let startTileX, startTileY;
      do {
        startTileX = Math.floor(Math.random() * roomWidth);
        startTileY = Math.floor(Math.random() * roomHeight);
      } while (newRoomMap[startTileY][startTileX] !== 0 && newRoomMap[startTileY][startTileX] !== 4);

      return {
        map: newRoomMap,
        discovered: discoveredTiles,
        startX: startTileX,
        startY: startTileY,
        width: roomWidth,
        height: roomHeight,
        enemyPositions: enemyPositions
      };
    }

    // Place a tile of a certain type in a random location
    function placeRandomTile(roomMap, tileType, mustBeEmpty = false) {
      const mapHeight = roomMap.length;
      const mapWidth = roomMap[0].length;

      let tries = 1000;
      while (tries-- > 0) {
        const randomX = Math.floor(Math.random() * mapWidth);
        const randomY = Math.floor(Math.random() * mapHeight);

        // Only place if not forced to be empty or if forced and actually empty
        if (!mustBeEmpty || (mustBeEmpty && roomMap[randomY][randomX] === 0)) {
          if (roomMap[randomY][randomX] === 0) {
            roomMap[randomY][randomX] = tileType;
            return { x: randomX, y: randomY };
          }
        }
      }
      return { x: 0, y: 0 }; // fallback
    }

    // Generate a new room for the next level and load it
    function generateAndLoadNextLevelRoom() {
      // Generate random room
      let {
        map, 
        discovered, 
        startX, 
        startY, 
        width, 
        height, 
        enemyPositions
      } = generateRandomRoom();

      // Prepare enemies array
      let enemiesInThisRoom = [];
      for (let position of enemyPositions) {
        let enemyPixelX = position.x * TILE_SIZE + (TILE_SIZE - ENEMY_SIZE) / 2;
        let enemyPixelY = position.y * TILE_SIZE + (TILE_SIZE - ENEMY_SIZE) / 2;

        const monsterKey = `${dungeonRooms.length}-${position.x}-${position.y}`;
        const monsterRef = monsterLookup[monsterKey];

        const directionsArray = [
          { xDir: 0,  yDir: -1 },
          { xDir: 0,  yDir: 1 },
          { xDir: -1, yDir: 0 },
          { xDir: 1,  yDir: 0 }
        ];
        const randomDirection = directionsArray[Math.floor(Math.random() * directionsArray.length)];

        enemiesInThisRoom.push({
          xPos: enemyPixelX,
          yPos: enemyPixelY,
          xDir: randomDirection.xDir,
          yDir: randomDirection.yDir,
          monster: monsterRef
        });
      }

      // Save this newly generated room data
      dungeonRooms[currentDungeonLevel - 1] = {
        map: map,
        discovered: discovered,
        startX: startX,
        startY: startY,
        width: width,
        height: height,
        enemies: enemiesInThisRoom
      };

      // Update current room index
      currentDungeonRoomIndex = currentDungeonLevel - 1;

      // Position the player in the newly generated room
      playerTileX = startX;
      playerTileY = startY;
      discovered[playerTileY][playerTileX] = true;
      discoverSurroundingTiles(playerTileX, playerTileY);

      // Reset combat state
      isInCombat = false;
      currentBattleMonster = null;
      currentFacingDirection = 'up';

      if(chance(70)) {
        placeMerchantInCurrentRoom();
      }

      updateEnvironmentPreview();
      renderVisibleTiles();
    }

    /*
      ---------------------------------------------------
      Game Loop (for smooth enemy movement)
      ---------------------------------------------------
    */

    function gameLoop() {
      // If not in combat, update enemy positions
      if (!isInCombat) {
        updateAllEnemies();
      }
      renderVisibleTiles();
      requestAnimationFrame(gameLoop);
    }

    /*
      ---------------------------------------------------
      Start the game
      ---------------------------------------------------
    */
    // Clear any existing rooms and monster references
    dungeonRooms = [];
    monsterLookup = {};
    currentDungeonLevel = 1;

    // Generate the first room and start the loop
    generateAndLoadNextLevelRoom();



    requestAnimationFrame(gameLoop);
    updateCombatUI();



    /**
 * Rolls a random chance based on the given percentage.
 *
 * @param {number} chance - The percentage chance (0 to 100) to return `true`.
 * @returns {boolean} - Returns `true` if the roll succeeds, `false` otherwise.
 */ function chance(chance) {
    if (chance < 0 || chance > 100) {
        throw new Error("Chance must be between 0 and 100.");
    }

    // Generate a random number between 0 and 100
    const randomRoll = Math.random() * 100;

    // Return true if the roll is within the chance percentage
    return randomRoll < chance;
}

/**
 * Generates a random number between the given min and max values.
 *
 * @param {number} min - The minimum value.
 * @param {number} max - The maximum value.
 * @returns {number} - A random number between min and max.
 */
 function randomBetween(min, max) {
    if (min > max) {
        throw new Error("Min must be less than or equal to Max.");
    }

    return Math.floor(Math.random() * (max - min) + min);
}


function useLootItem(item) {
    if (item.poa === 'passive') {
        return;
    }

    if (item.type === 'heal') {
        playerCharacter.health += item.effect;
        if (playerCharacter.health > playerCharacter.startingHealth) {
            playerCharacter.health = playerCharacter.startingHealth;
        }
        notify(`You used ${item.name} and healed ${item.effect} health!`);
    }

    if (item.name === 'grenade') {
      currentBattleMonster.health -= item.effect;
    }

    // Remove the used item from inventory
    playerCharacter.inventory = playerCharacter.inventory.filter(i => i.id !== item.id);

    updateCombatUI();
}
  </script>
</body>
</html>
